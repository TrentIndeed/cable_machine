<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Three.js CAD — Servo + 2-Stage Belts + Drum (import map fix)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- Import map so example modules can resolve the bare 'three' specifier -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#0b0f14;color:#e6eef8;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #hud{position:fixed;left:10px;top:10px;display:flex;gap:8px;z-index:10}
  .btn{background:#1e293b;border:1px solid #334155;color:#e6eef8;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .btn:hover{background:#0f172a}
  #panel{position:fixed;right:10px;bottom:10px;background:#0b1220cc;border:1px solid #334155;border-radius:10px;padding:10px 12px;z-index:10;min-width:280px}
  #panel h3{margin:0 0 6px 0;font-size:14px}
  #panel label{display:flex;justify-content:space-between;gap:8px;margin:4px 0;font-size:12px}
  #panel input,#panel select{flex:1;background:#0f172a;color:#e6eef8;border:1px solid #334155;border-radius:6px;padding:4px 6px}
  #readout{position:fixed;right:10px;top:10px;background:#0b1220cc;border:1px solid #334155;border-radius:10px;padding:10px 12px;z-index:10;min-width:260px;font-size:12px;line-height:1.35}
  #diag{position:fixed;left:10px;bottom:10px;background:#111827cc;border:1px solid #374151;border-radius:8px;padding:8px 10px;max-width:46vw;max-height:28vh;overflow:auto;font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; z-index:10}
  #hint{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);font-size:12px;opacity:.85}
  canvas{display:block;width:100%;height:100%}
</style>
</head>
<body>
<div id="hud">
  <button id="start" class="btn">▶ Start</button>
  <button id="stop" class="btn">⏸ Stop</button>
  <button id="reset" class="btn">↺ Reset View</button>
</div>
<div id="readout"></div>
<div id="panel">
  <h3>Parameters</h3>
  <label>Motor RPM <input type="number" id="rpm" value="3000" min="100" max="4000" step="10"></label>
  <label>Stage1 small T <select id="T1"><option>18</option><option>20</option><option selected>22</option><option>24</option></select></label>
  <label>Stage1 large T <select id="T2"><option>48</option><option>54</option><option selected>60</option><option>64</option></select></label>
  <label>Stage2 small T <select id="T3"><option>18</option><option>20</option><option selected>22</option><option>24</option></select></label>
  <label>Stage2 large T <select id="T4"><option>42</option><option selected>48</option><option>54</option><option>60</option></select></label>
  <label>Drum OD (mm) <input type="number" id="drumOD" value="100" min="40" max="160"></label>
  <label>Drum Face (mm) <input type="number" id="drumFace" value="75" min="30" max="120"></label>
  <label>Plane1 Y <input type="number" id="p1y" value="60" min="40" max="100"></label>
  <label>Plane2 Y <input type="number" id="p2y" value="130" min="110" max="160"></label>
</div>
<div id="diag"></div>
<div id="hint">Drag = orbit • Wheel = zoom • Shift+Drag = pan • Click Start to animate</div>
<canvas id="c"></canvas>

<script type="module">
const diag = document.getElementById('diag');
function log(msg){ diag.textContent += msg + "\n"; diag.scrollTop = diag.scrollHeight; }
window.addEventListener('error', (e)=>{
  log('[window.error] '+ (e.message||e.error));
});
window.addEventListener('unhandledrejection', (e)=>{
  log('[promise] '+ e.reason);
});

// Since we provide an import map, we can use bare specifiers directly:
import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
import { CSS2DRenderer, CSS2DObject } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js';
import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/geometries/TextGeometry.js';

log('✔ Imports resolved via import map');

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color('#0b0f14');

const encW=650, encH=360, encD=380; // Compacted depth
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 50000);
camera.position.set(encW + 400, encH + 200, encD/2); // Adjusted camera for new size

const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(innerWidth, innerHeight);
labelRenderer.domElement.style.position='fixed';
labelRenderer.domElement.style.left='0';
labelRenderer.domElement.style.top='0';
labelRenderer.domElement.style.pointerEvents='none';
document.body.appendChild(labelRenderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(encW/2, encH/2, encD/2); controls.update(); // Center target on enclosure

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.8); hemi.position.set(0,1,0); scene.add(hemi);
const key = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(1200, 1200, 900); scene.add(key);
const fill = new THREE.DirectionalLight(0xffffff, 0.6); fill.position.set(-800, 600, -900); scene.add(fill);

const grid = new THREE.GridHelper(2000, 40, 0x64748b, 0x1f2937); grid.position.y=0; scene.add(grid);

const materials = {
  steel: new THREE.MeshStandardMaterial({ color:0xb9c0c7, metalness:0.75, roughness:0.35 }),
  dark:  new THREE.MeshStandardMaterial({ color:0x3b4453, metalness:0.65, roughness:0.55 }),
  belt:  new THREE.MeshStandardMaterial({ color:0x0a0f14, metalness:0.1, roughness:0.95 }),
  drum:  new THREE.MeshStandardMaterial({ color:0xd7dde4, metalness:0.55, roughness:0.35 }),
  cable: new THREE.MeshStandardMaterial({ color:0xdc2626, metalness:0.7, roughness:0.2 }),
  glass: new THREE.MeshPhysicalMaterial({ color:0x7fb0ff, metalness:0, roughness:0.08, transmission:0.9, transparent:true, opacity:0.2, side:THREE.DoubleSide, clearcoat:1, clearcoatRoughness:0.02 }),
  transformer: new THREE.MeshStandardMaterial({ color: 0x2d3748, metalness: 0.6, roughness: 0.4 }),
  resistor: new THREE.MeshStandardMaterial({ color: 0xe2e8f0, metalness: 0.2, roughness: 0.7 }),
  loadcell: new THREE.MeshStandardMaterial({ color: 0xd1d5db, metalness: 0.9, roughness: 0.2 }),
  screenBody: new THREE.MeshStandardMaterial({ color: 0x1e293b, metalness: 0.3, roughness: 0.8 }),
  screenFace: new THREE.MeshStandardMaterial({ color: 0x2dd4bf, metalness: 0.1, roughness: 0.2 }),
  text: new THREE.MeshStandardMaterial({ color: 0xe6eef8, metalness: 0.5, roughness: 0.4 }),
};

// Parameters for the vertically rotated layout, with motor mounted to the side
const P = {
  encW, encH, encD,
  shaftY: 200.0,
  // Z-coordinates for flipped Stage 2 to save space
  zMotor: 150.0,
  zJack: 150.0 + 139.6, // 289.6
  zDrum: (150.0 + 139.6) - 168.8, // 120.8. Stage 2 is reversed.
  pitch: 8, beltW: 30,
  T1: 22, T2: 60, T3: 22, T4: 48,
  drumOD: 100, drumFace: 80,
  motorW: 130, motorH: 130, motorL: 279, motorRPM: 3000,
  running:false
};

function PD(teeth){ return teeth * P.pitch / Math.PI; }
function rT(t){ return PD(t)/2; }

const mech = new THREE.Group(); scene.add(mech);
const belts = new THREE.Group(); scene.add(belts);

function buildEnclosure(xDivider, xFairlead){
  const g = new THREE.BoxGeometry(P.encW, P.encH, P.encD);
  const box = new THREE.Mesh(g, materials.glass); box.position.set(P.encW/2, P.encH/2, P.encD/2); box.userData.isEnclosure = true;
  const edges = new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color:0x60a5fa })); edges.position.copy(box.position); edges.userData.isEnclosure = true;
  const divider = new THREE.Mesh(new THREE.BoxGeometry(6, P.encH, P.encD*0.95), materials.dark); divider.position.set(xDivider, P.encH/2, P.encD/2); divider.userData.isEnclosure = true;
  const fairlead = new THREE.Mesh(new THREE.BoxGeometry(70, 25, 10), materials.dark);
  fairlead.position.set(xFairlead, 200, 5); // Use calculated X
  scene.add(box, edges, divider, fairlead);
}

let p22A,p60,p22B,p48,drum,cable,belt1,belt2;

// Shafts are parallel to X-axis, so rotate geometry accordingly
function pulleyMesh(teeth, width){ const r=rT(teeth); const m=new THREE.Mesh(new THREE.CylinderGeometry(r,r,width,96), materials.steel); m.rotation.z=Math.PI/2; m.userData={type:'pulley',teeth, PD:PD(teeth)}; return m; }
function buildDrum(){ const r=P.drumOD/2; const m=new THREE.Mesh(new THREE.CylinderGeometry(r,r,P.drumFace,96), materials.drum); m.rotation.z=Math.PI/2; m.userData={type:'drum'}; return m; }
function buildCable(xDrum){
  const cableRadius = 4.75 / 2;
  const drumRadius = P.drumOD / 2;
  const pitch = cableRadius * 2.1; // Spacing between wraps
  const numWraps = Math.floor((P.drumFace * 0.8) / pitch); // Use 80% of the drum face for wraps
  const segmentsPerWrap = 32;
  const points = [];

  // 1. Create the spiral part on the drum.
  // The cable unwinds from xDrum, so we spool away from that point.
  for (let i = 0; i < numWraps * segmentsPerWrap; i++) {
    const wrapFraction = i / segmentsPerWrap;
    const angle = -Math.PI / 2 + (wrapFraction * 2 * Math.PI); // Wrap direction
    const x = xDrum - (wrapFraction * pitch);

    // Ensure we don't spool off the drum
    if (Math.abs(x - xDrum) > P.drumFace / 2) continue;

    const y = P.shaftY + drumRadius * Math.cos(angle);
    const z = P.zDrum + drumRadius * Math.sin(angle);
    points.push(new THREE.Vector3(x, y, z));
  }
  points.reverse(); // Make the path go from the inner wrap outwards

  // 2. Add the straight part to the fairlead.
  // This ensures a smooth exit from the drum towards the fairlead.
  points.push(new THREE.Vector3(xDrum, P.shaftY, P.zDrum - drumRadius));
  points.push(new THREE.Vector3(xDrum, P.shaftY, 0));

  // 3. Create the tube geometry from the points.
  const path = new THREE.CatmullRomCurve3(points);
  const tubeGeo = new THREE.TubeGeometry(path, 256, cableRadius, 8, false);
  const cable = new THREE.Mesh(tubeGeo, materials.cable);
  cable.userData = {type:'cable'};
  return cable;
}

function buildShaft(x_start, x_end, y, z, radius = 15) {
  const length = Math.abs(x_end - x_start);
  const shaftGeo = new THREE.CylinderGeometry(radius, radius, length, 32);
  const shaft = new THREE.Mesh(shaftGeo, materials.steel);
  shaft.rotation.z = Math.PI / 2; // Align with X-axis
  shaft.position.set((x_start + x_end) / 2, y, z);
  return shaft;
}

function buildElectronics(xDivider) {
  const elecBayX = (xDivider + P.encW) / 2;

  // Transformer (large, on the floor)
  const tfW = 160, tfH = 180, tfD = 150;
  const transformer = new THREE.Mesh(new THREE.BoxGeometry(tfW, tfH, tfD), materials.transformer);
  transformer.position.set(elecBayX, tfH/2, P.encD - tfD/2 - 20);
  mech.add(transformer);

  // Braking Resistor (smaller, mounted higher)
  const resW = 180, resH = 40, resD = 80;
  const resistor = new THREE.Mesh(new THREE.BoxGeometry(resW, resH, resD), materials.resistor);
  resistor.position.set(elecBayX, P.encH - resH/2 - 20, P.zJack);
  mech.add(resistor);

  // Load Cell (small, near the cable exit)
  const lcW = 30, lcH = 30, lcD = 80;
  const loadcell = new THREE.Mesh(new THREE.BoxGeometry(lcW, lcH, lcD), materials.loadcell);
  loadcell.position.set(xDivider + 30, P.shaftY, 40);
  mech.add(loadcell);

  // Rotary Screen (M5Dial)
  const dialGroup = new THREE.Group();
  const dialRadius = 35, dialDepth = 15;
  const body = new THREE.Mesh(new THREE.CylinderGeometry(dialRadius, dialRadius, dialDepth, 64), materials.screenBody);
  const face = new THREE.Mesh(new THREE.CylinderGeometry(dialRadius * 0.8, dialRadius * 0.8, 1, 64), materials.screenFace);
  face.position.y = dialDepth/2 + 0.5; // Cylinder is built along Y, so move face to top
  dialGroup.add(body, face);

  // Add Text if font is loaded
  if (font) {
      const textGeo = new TextGeometry('150lb', {
          font: font,
          size: 10, // Smaller size to fit on screen
          height: 2,
          curveSegments: 12,
      });
      textGeo.center(); // Center the text geometry
      const textMesh = new THREE.Mesh(textGeo, materials.text);
      textMesh.rotation.x = -Math.PI / 2; // Rotate text to lay flat on the screen
      textMesh.position.y = dialDepth/2 + 2; // Position text on top of the screen face
      dialGroup.add(textMesh);
  }

  // Position and orient the entire dial group to be on the outside of the front panel
  dialGroup.rotation.x = Math.PI/2; // Point the screen face outwards
  dialGroup.rotation.z = Math.PI;   // Flip the screen 180 degrees to be upright
  dialGroup.position.set(565, 220, 5 - dialDepth/2); // Position fully outside the front panel (fairlead face)
  mech.add(dialGroup);
}

let font;

function rebuild(){
  mech.clear(); belts.clear();
  scene.children = scene.children.filter(obj => !(obj.userData && obj.userData.isEnclosure));

  // Calculate X positions for components, starting from motor
  const clearance = 10;
  const xBelt1 = P.motorL + 28; // Center of motor shaft pulley
  const xBelt2 = xBelt1 + P.beltW/2 + clearance + P.beltW/2;
  const xDrum = xBelt2 + P.beltW/2 + clearance + P.drumFace/2;
  const xDivider = xDrum + P.drumFace/2 + clearance;

  buildEnclosure(xDivider, xDrum);
  buildElectronics(xDivider);

  // Mount motor back to enclosure wall (X=0)
  const motor = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(P.motorL, P.motorH, P.motorW), materials.dark);
  const shaft = new THREE.Mesh(new THREE.CylinderGeometry(11,11,57,32), materials.steel);
  shaft.rotation.z = Math.PI/2; // Align shaft with X-axis
  shaft.position.x = P.motorL/2 + 28;
  motor.add(body,shaft);
  motor.position.set(P.motorL/2, P.shaftY, P.zMotor); // Motor center at L/2
  mech.add(motor);

  // Add shafts
  const jackShaft = buildShaft(0, xDivider, P.shaftY, P.zJack);
  mech.add(jackShaft);
  const drumShaft = buildShaft(xBelt2 - P.beltW, xDivider, P.shaftY, P.zDrum);
  mech.add(drumShaft);

  p22A = pulleyMesh(P.T1,P.beltW); p22A.position.set(xBelt1, P.shaftY, P.zMotor); mech.add(p22A);
  p60  = pulleyMesh(P.T2,P.beltW); p60.position.set(xBelt1, P.shaftY, P.zJack);  mech.add(p60);
  p22B = pulleyMesh(P.T3,P.beltW); p22B.position.set(xBelt2, P.shaftY, P.zJack);  mech.add(p22B);
  p48  = pulleyMesh(P.T4,P.beltW); p48.position.set(xBelt2, P.shaftY, P.zDrum);  mech.add(p48);
  drum = buildDrum(); drum.position.set(xDrum, P.shaftY, P.zDrum); mech.add(drum);
  cable = buildCable(xDrum);
  mech.add(cable);

  const beltThick = 6;
  belt1 = createBelt(rT(P.T1), P.zMotor, rT(P.T2), P.zJack, P.shaftY, P.beltW, beltThick);
  belt1.position.x = xBelt1;
  belts.add(belt1);

  // Swapped args so smaller Z-coordinate is first, ensuring correct belt wrap
  belt2 = createBelt(rT(P.T4), P.zDrum, rT(P.T3), P.zJack, P.shaftY, P.beltW, beltThick);
  belt2.position.x = xBelt2;
  belts.add(belt2);

  updateReadout();
  controls.target.set(P.encW/2, P.encH/2, P.encD/2); controls.update();
}

function createBelt(r1, z1, r2, z2, y, width, thick) {
  const d = z2 - z1;
  const shape = new THREE.Shape();

  // Angle for tangent points is the same for inner and outer paths
  const alpha = Math.asin((r2 - r1) / d);

  // --- Outer Path ---
  const r1o = r1 + thick;
  const r2o = r2 + thick;

  const p1_upper = { x: z1 - r1o * Math.sin(alpha), y: y + r1o * Math.cos(alpha) };
  const p2_upper = { x: z2 - r2o * Math.sin(alpha), y: y + r2o * Math.cos(alpha) };
  const p1_lower = { x: z1 + r1o * Math.sin(alpha), y: y - r1o * Math.cos(alpha) };
  const p2_lower = { x: z2 + r2o * Math.sin(alpha), y: y - r2o * Math.cos(alpha) };

  const angle1_start_outer = Math.atan2(p1_lower.y - y, p1_lower.x - z1);
  const angle1_end_outer = Math.atan2(p1_upper.y - y, p1_upper.x - z1);
  const angle2_start_outer = Math.atan2(p2_upper.y - y, p2_upper.x - z2);
  const angle2_end_outer = Math.atan2(p2_lower.y - y, p2_lower.x - z2);

  shape.moveTo(p1_upper.x, p1_upper.y);
  shape.lineTo(p2_upper.x, p2_upper.y);
  shape.absarc(z2, y, r2o, angle2_start_outer, angle2_end_outer, true);
  shape.lineTo(p1_lower.x, p1_lower.y);
  shape.absarc(z1, y, r1o, angle1_start_outer, angle1_end_outer, true); // Corrected angle order

  // --- Inner Path (Hole) ---
  const hole = new THREE.Path();

  const h_p1_upper = { x: z1 - r1 * Math.sin(alpha), y: y + r1 * Math.cos(alpha) };
  const h_p2_upper = { x: z2 - r2 * Math.sin(alpha), y: y + r2 * Math.cos(alpha) };
  const h_p1_lower = { x: z1 + r1 * Math.sin(alpha), y: y - r1 * Math.cos(alpha) };
  const h_p2_lower = { x: z2 + r2 * Math.sin(alpha), y: y - r2 * Math.cos(alpha) };

  const h_angle1_start = Math.atan2(h_p1_lower.y - y, h_p1_lower.x - z1);
  const h_angle1_end = Math.atan2(h_p1_upper.y - y, h_p1_upper.x - z1);
  const h_angle2_start = Math.atan2(h_p2_upper.y - y, h_p2_upper.x - z2);
  const h_angle2_end = Math.atan2(h_p2_lower.y - y, h_p2_lower.x - z2);

  hole.moveTo(h_p1_upper.x, h_p1_upper.y);
  hole.lineTo(h_p2_upper.x, h_p2_upper.y);
  hole.absarc(z2, y, r2, h_angle2_start, h_angle2_end, true);
  hole.lineTo(h_p1_lower.x, h_p1_lower.y);
  hole.absarc(z1, y, r1, h_angle1_start, h_angle1_end, true); // Corrected angle order
  shape.holes.push(hole);

  const extrudeSettings = { depth: width, bevelEnabled: false };
  const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  
  // The shape is in the XY plane, but we need it in the YZ plane.
  // We rotate it and then translate to center it.
  geometry.rotateY(-Math.PI / 2);
  geometry.translate(width / 2, 0, 0);
  
  return new THREE.Mesh(geometry, materials.belt);
}

function totalRatio(){ return (P.T2/P.T1)*(P.T4/P.T3); }
function drumRPM(){ return P.motorRPM / totalRatio(); }
function cableSpeedMps(){ return (Math.PI * P.drumOD/1000) * (drumRPM()/60); }
function updateReadout(){ const mph=cableSpeedMps()*2.23694; document.getElementById('readout').innerHTML=`<b>Assembly</b><br>Ratio: <b>${totalRatio().toFixed(2)}:1</b><br>Motor RPM: <b>${P.motorRPM.toFixed(0)}</b><br>Drum RPM: <b>${drumRPM().toFixed(1)}</b><br>Cable speed: <b>${cableSpeedMps().toFixed(2)} m/s</b> (~<b>${mph.toFixed(2)} mph</b>)<br>Drum: <b>${P.drumOD} × ${P.drumFace} mm</b><br>Pulleys: <b>${P.T1}→${P.T2}</b> & <b>${P.T3}→${P.T4}</b>`; }

let last = performance.now();
function animate(now){
  const dt=(now-last)/1000; last=now;
  if(P.running){
    const theta=(P.motorRPM/60)*2*Math.PI*dt;
    const r1=P.T1/P.T2;
    const r2=P.T3/P.T4;
    // Rotation is around the X axis
    p22A.rotation.x += theta;
    p60.rotation.x  += theta*r1;
    p22B.rotation.x += theta*r1;
    p48.rotation.x  -= theta*r1*r2; // Flipped direction
    drum.rotation.x -= theta*r1*r2; // Flipped direction
  }
  renderer.render(scene,camera); labelRenderer.render(scene,camera); requestAnimationFrame(animate);
}

function bindUI(){
  function gi(id){return document.getElementById(id);} function val(id){return parseInt(gi(id).value,10);}
  ['rpm','T1','T2','T3','T4','drumOD','drumFace','p1y','p2y'].forEach(id=>{
    const el = gi(id);
    if (el) {
      el.addEventListener('input',()=>{
        P.motorRPM=val('rpm'); P.T1=val('T1'); P.T2=val('T2'); P.T3=val('T3'); P.T4=val('T4'); P.drumOD=val('drumOD'); P.drumFace=val('drumFace');
        rebuild();
      });
    }
  });
  gi('start').onclick=()=>{ P.running=true; };
  gi('stop').onclick =()=>{ P.running=false; };
  gi('reset').onclick=()=>{ camera.position.set(P.encW + 400, encH + 200, encD/2); controls.target.set(P.encW/2, P.encH/2, P.encD/2); controls.update(); };
}

const loader = new FontLoader();
loader.load('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
    font = loadedFont;
    rebuild(); // Initial build once font is loaded
});

bindUI(); 
requestAnimationFrame(animate);

window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); labelRenderer.setSize(innerWidth, innerHeight); });
</script>
</body>
</html>