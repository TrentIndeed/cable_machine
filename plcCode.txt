GVL_IO:
VAR_GLOBAL
	// HARDWARE MAPPINGS (Link these in the IO tree to the Delta Drive PDOs)
	// Outputs (Master -> Drive)
	Left_ControlWord   AT %Q* : UINT;  // Map to 0x6040
	Left_TargetTorque  AT %Q* : INT;   // Map to 0x6071
	Left_OpMode        AT %Q* : SINT;  // Map to 0x6060
	
	Right_ControlWord  AT %Q* : UINT;  // Map to 0x6040
	Right_TargetTorque AT %Q* : INT;   // Map to 0x6071
	Right_OpMode       AT %Q* : SINT;  // Map to 0x6060
	
	// Inputs (Drive -> Master)
	Left_StatusWord    AT %I* : UINT;  // Map to 0x6041
	Left_ActualTq      AT %I* : INT;   // Map to 0x6077
	Left_OpModeDisplay AT %I* : SINT;  // Map to 0x6061
	
	Right_StatusWord   AT %I* : UINT;  // Map to 0x6041
	Right_ActualTq     AT %I* : INT;   // Map to 0x6077
	Right_OpModeDisplay AT %I* : SINT; // Map to 0x6061
END_VAR

GVL_UI:
{attribute 'qualified_only' := 'FALSE'}
VAR_GLOBAL
    // UI / App interface (you already have these DUTs)
    Cmd       : ST_UI_Command;
    Telemetry : ST_UI_Telemetry;
END_VAR

PROGRAM MAIN
VAR
    // NC axis refs (linked in MOTION tree)
    axis_left  : AXIS_REF;  
    axis_right : AXIS_REF;

	// NC Reset Blocks (Still needed to clear hardware/NC faults)
	fbResetL : MC_Reset;
	fbResetR : MC_Reset;
	
	// Logic Variables
	lastSeq        : DINT := -1;
	bEnableRequest : BOOL := FALSE;
	bDoReset       : BOOL := FALSE;
	
	// Torque calculation
	targetTorqueRaw : INT := 0; 
	
	// State machine for CiA402 Enable
	nStateL : INT := 0;
	nStateR : INT := 0;
	
	// Internal Velocity Monitors
	fLeftVelo  : LREAL;
	fRightVelo : LREAL;
END_VAR

// --- 1. COMMAND HANDLING (Sync with UI) ---
IF GVL_UI.Cmd.Seq <> lastSeq THEN
lastSeq := GVL_UI.Cmd.Seq;
bDoReset := FALSE;

CASE GVL_UI.Cmd.CmdType OF
    1: // Enable Request
        bEnableRequest := TRUE; 
    2: // Disable
        bEnableRequest := FALSE; 
        targetTorqueRaw := 0;
    4, 5: // SetResistance or SetForce
        // Delta B3 Units: 0.1% of rated torque.
        // UI 10.0 -> 100 raw -> 10% torque.
        targetTorqueRaw := TO_INT(GVL_UI.Cmd.Param1 * 10.0);
    6: // Reset
        bDoReset := TRUE;
END_CASE
GVL_UI.Cmd.AckSeq := lastSeq;


END_IF

// --- 2. NC AXIS MAINTENANCE ---
axis_left.ReadStatus();
axis_right.ReadStatus();

fbResetL(Axis := axis_left, Execute := bDoReset OR (bEnableRequest AND axis_left.Status.Error));
fbResetR(Axis := axis_right, Execute := bDoReset OR (bEnableRequest AND axis_right.Status.Error));

// --- 3. VELOCITY CAPTURE ---
fLeftVelo  := axis_left.NcToPlc.ActVelo;
fRightVelo := axis_right.NcToPlc.ActVelo;

// --- 4. DIRECT DRIVE CONTROL (CiA402 State Machine) ---
// Force the drive into Mode 10 (Cyclic Synchronous Torque)
Left_OpMode  := 10;
Right_OpMode := 10;

// Enable Logic for Left Axis
IF NOT bEnableRequest THEN
Left_ControlWord := 16#0000;
nStateL := 0;
ELSE
CASE nStateL OF
0: // Step 1: Ready to Switch On
Left_ControlWord := 16#0006;
IF (Left_StatusWord AND 16#0021) = 16#0021 THEN nStateL := 1; END_IF
1: // Step 2: Switched On
Left_ControlWord := 16#0007;
IF (Left_StatusWord AND 16#0023) = 16#0023 THEN nStateL := 2; END_IF
2: // Step 3: Operation Enabled
Left_ControlWord := 16#000F;
IF (Left_StatusWord AND 16#0008) = 16#0008 THEN nStateL := 0; END_IF
END_CASE
END_IF

// Enable Logic for Right Axis
IF NOT bEnableRequest THEN
Right_ControlWord := 16#0000;
nStateR := 0;
ELSE
CASE nStateR OF
0: Right_ControlWord := 16#0006;
IF (Right_StatusWord AND 16#0021) = 16#0021 THEN nStateR := 1; END_IF
1: Right_ControlWord := 16#0007;
IF (Right_StatusWord AND 16#0023) = 16#0023 THEN nStateR := 2; END_IF
2: Right_ControlWord := 16#000F;
IF (Right_StatusWord AND 16#0008) = 16#0008 THEN nStateR := 0; END_IF
END_CASE
END_IF

// --- 5. TORQUE INJECTION ---
// Bit 2 (16#0004) is "Operation Enabled".
// We write torque if the drive is powered on and bEnableRequest is true.
IF (Left_StatusWord AND 16#0004) = 16#0004 AND bEnableRequest THEN
Left_TargetTorque := targetTorqueRaw;
ELSE
Left_TargetTorque := 0;
END_IF

IF (Right_StatusWord AND 16#0004) = 16#0004 AND bEnableRequest THEN
Right_TargetTorque := targetTorqueRaw;
ELSE
Right_TargetTorque := 0;
END_IF

// --- 6. TELEMETRY ---
GVL_UI.Telemetry.Connected := TRUE;
GVL_UI.Telemetry.LeftPos    := TO_REAL(axis_left.NcToPlc.ActPos);
GVL_UI.Telemetry.LeftVel    := TO_REAL(fLeftVelo);
GVL_UI.Telemetry.RightPos   := TO_REAL(axis_right.NcToPlc.ActPos);
GVL_UI.Telemetry.RightVel   := TO_REAL(fRightVelo);

GVL_UI.Telemetry.LeftForce  := TO_REAL(Left_ActualTq);
GVL_UI.Telemetry.RightForce := TO_REAL(Right_ActualTq);

// Diagnostic: Show the nState and StatusWord bits.
// If it shoshows 2039, it's commanding torque.
GVL_UI.Telemetry.CmdStatus  := TO_INT(nStateL * 1000 + (Left_StatusWord AND 16#00FF));